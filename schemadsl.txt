GraphQL only specifies types. We want to specify
- types
- pattern/format
- conditionals
- formatters
- default values
- severity
- meta-data
	- name
	- description
	- helpText
- error message

Inspiration:
- http://graphql.org/learn/schema/
	- http://graphql.org/graphql-js/type/#graphqlscalartype
- https://www.typescriptlang.org/
- https://flow.org/
- http://json-schema.org/
	- http://json-schema.org/examples.html
	- https://www.jsonschemavalidator.net/
	- https://spacetelescope.github.io/understanding-json-schema/
	- https://github.com/epoberezkin/ajv-errors
- https://pegjs.org/online
- https://www.json.org/

GraphQL:

	type Character {
	  name: String!
	  appearsIn: [Episode]!
	}
	
	query DroidById($id: ID!) {
	  droid(id: $id) {
	    name
	  }
	}	

PegJS:
	
	value
	  = false
	  / null
	  / true
	  / object
	  / array
	  / number
	  / string


	object
	  = begin_object
	    members:(
	      head:member
	      tail:(value_separator m:member { return m; })*
	      {
	        var result = {};
	
	        [head].concat(tail).forEach(function(element) {
	          result[element.name] = element.value;
	        });
	
	        return result;
	      }
	    )?
	    end_object
	    { return members !== null ? members: {}; }
	    
TypeScript:

	interface LabelledValue {
	    label: string;
	}
	
	type custCreditTuple = [string, Customer, number];
	
	enum Color {Red, Green, Blue}
	
	any
	
	type Shape = Square | Rectangle;
	
	// intersection types
	
	type Human = Person & Serializable & Loggable
	
	
Our DSL:
    
Each file represents a schema for a single form. We need to export a "default" as the root of the form. In PegJS, 
the first rule is the startRule. In JS, we use "export default". In GraphQL, there is no start -- each schema defines
many types. I'm thinking we use a keyword to designate one of the rules as the entrypoint? Like "schema".

	schema Foo = {
		
	}

Exports a schema named "Foo"

	schema = {
	
	}
	
Exports this as the root schema..? This way we can optionally have multiple schemas in one file.

	schema = {
		firstName: string
		lastName: string
		age: number
		isMarried: boolean
	}

Basic types (per json.org): string, number, object, array, true, false, null

A "type" is one of the basic types.
A "rule" is a type + pattern/format + error message + severity
A "property" (or "field"?) has a rule + name + default value + [formatter?]

Can properties given types, or only rules? A type is kind of like a rule with no arguments...

	rule PhoneNumber($country: string = "CA") {
		type: string
		pattern: [0-9-()]+
		message: "Invalid phone number"
	}

(How to support arguments? Should we?)

	schema = { # schema is an object <--- bad: 1. schema has to be a field, not a type. 2. how do we define rules on the object itself, like min/max properties?
		homePhone <
			rule: PhoneNumberCA | PhoneNumberUS
			name: "Home Phone"
			description: "The telephone number we can reach you at home"
			helpText: "Should be formatted like \"(888) 888-8888\" or \"+1 (888) 888-8888 ext. 1234\""
			required: true # property must be present
		>
	}
	
	schema = < # schema consists of a single field
		rule: BirthDate
		name: "Date of Birth"
		description: "The date you were born"
	>
	
	schema = [ FirstName, LastName] # the entire schema is a fixed-length tuple like https://blogs.msdn.microsoft.com/typescript/2018/01/17/announcing-typescript-2-7-rc/#fixed-length-tuples
	
	schema = "foo" | "bar" | 7 # schema must be one of these literals -- but don't these need to be 'fields' so we can do the error message properly?
	
	rule MinLength($length: number) {
		type: string
		message: "Must be at least ${length} characters"
		# We can't put the actual code this here... I guess this will act like graphql's "scalar" and you'll have to fill
		# in the logic on the backend...?
	}
	
	field FirstName = < # should the keyword be "field" or just "type"? The <> already denote this is a 'field' type -- I guess that depends on if schemas can be types or must be fields
		rule: MinLength(2)
	>

In Form Capacitor 2, everything is a "field". An entire form is just a complex field. A "DateTime" must consist of two sub-fields: "Date and Time". A "Scheduling Instruction" (see examles) is a complex field with several subfields. Therefore the schema root should also be a field, and we should not allow objects, or union types at the root (above examples should be invalid).

But if everything is a field, and each field has its own name and error message, are we not doubling-down on the errors?

	schema <
		name: "Scheduling Instructions",
		message: "The form is invalid",
		rule: <
			type: { # the type has to be a type. in this case it's an object, and we are defining it inline
				instructions: <
					# how *do* we define this as an array..!?!
					# it should be an array of Instructions, but Instruction is not a type, it's a field
					type: []
				>
			}
		>
	>

TypeScript and GraphQL differ in how they document arrays. In GraphQL `[Int]` is an arbitrary-length array.
In TypeScript `[number]` is a tuple with 1 element, which is a number, and `number[]` is an array of numbers. They
also allow `Array<number>` (see https://www.typescriptlang.org/docs/handbook/basic-types.html#array). I think we
should only allow one syntax. And `(number | string)[]`. I think we should go with the last one, since we want to
save angle brackets for "fields".

Operators:

	|    or
	&    and
	^    -xor-[oneOf] (one or the other but not both -- can *sort of* translate to JsonSchema via OneOf?? -- what is a^b^c? Is that "one of" a, b, or c but not two or more? Or... (a^b)^c?
							which would mean if a and b are the same truthiness then c must be true, but if they differ then a^b is true, so c must be false... so
							a^b^c^d^... is basically like checking if an odd number are truthy
							but maybe ^ *shouldn't* be a binary operator in our language and if you want it to be, you can add parens!!
							ergo, a^b^c means "one of" and (a^b)^c acts like traditional xor. So... ^ is just the "one of" operator then.
							
Our DSL should *require* parens when mixing operators so that order of operations is never a concern!!
