GraphQL only specifies types. We want to specify
- types
- pattern/format
- conditionals
- formatters
- default values
- severity
- meta-data
	- name
	- description
	- helpText
- error message

Inspiration:
- http://graphql.org/learn/schema/
	- http://graphql.org/graphql-js/type/#graphqlscalartype
- https://www.typescriptlang.org/
- https://flow.org/
- http://json-schema.org/
	- http://json-schema.org/examples.html
	- https://www.jsonschemavalidator.net/
	- https://spacetelescope.github.io/understanding-json-schema/
	- https://github.com/epoberezkin/ajv-errors
- https://pegjs.org/online
- https://www.json.org/

Libs:
- https://astexplorer.net/

GraphQL:

	type Character {
	  name: String!
	  appearsIn: [Episode]!
	}
	
	query DroidById($id: ID!) {
	  droid(id: $id) {
	    name
	  }
	}	

PegJS:
	
	value
	  = false
	  / null
	  / true
	  / object
	  / array
	  / number
	  / string


	object
	  = begin_object
	    members:(
	      head:member
	      tail:(value_separator m:member { return m; })*
	      {
	        var result = {};
	
	        [head].concat(tail).forEach(function(element) {
	          result[element.name] = element.value;
	        });
	
	        return result;
	      }
	    )?
	    end_object
	    { return members !== null ? members: {}; }
	    
TypeScript:

	interface LabelledValue {
	    label: string;
	}
	
	type custCreditTuple = [string, Customer, number];
	
	enum Color {Red, Green, Blue}
	
	any
	
	type Shape = Square | Rectangle;
	
	// intersection types
	
	type Human = Person & Serializable & Loggable
	
	
Our DSL:
    
Each file represents a schema for a single form. We need to export a "default" as the root of the form. In PegJS, 
the first rule is the startRule. In JS, we use "export default". In GraphQL, there is no start -- each schema defines
many types. I'm thinking we use a keyword to designate one of the rules as the entrypoint? Like "schema".

	schema Foo = {
		
	}

Exports a schema named "Foo"

	schema = {
	
	}
	
Exports this as the root schema..? This way we can optionally have multiple schemas in one file.

	schema = {
		firstName: string
		lastName: string
		age: number
		isMarried: boolean
	}

Basic types (per json.org): string, number, object, array, true, false, null

A "type" is one of the basic types.
A "rule" is a type + pattern/format + error message + severity
A "property" (or "field"?) has a rule + name + default value + [formatter?]

Can properties given types, or only rules? A type is kind of like a rule with no arguments...

	rule PhoneNumber($country: string = "CA") {
		type: string
		pattern: [0-9-()]+
		message: "Invalid phone number"
	}

(How to support arguments? Should we?)

	schema = { # schema is an object <--- bad: 1. schema has to be a field, not a type. 2. how do we define rules on the object itself, like min/max properties?
		homePhone <
			rule: PhoneNumberCA | PhoneNumberUS
			name: "Home Phone"
			description: "The telephone number we can reach you at home"
			helpText: "Should be formatted like \"(888) 888-8888\" or \"+1 (888) 888-8888 ext. 1234\""
			required: true # property must be present
		>
	}
	
	schema = < # schema consists of a single field
		rule: BirthDate
		name: "Date of Birth"
		description: "The date you were born"
	>
	
	schema = [ FirstName, LastName] # the entire schema is a fixed-length tuple like https://blogs.msdn.microsoft.com/typescript/2018/01/17/announcing-typescript-2-7-rc/#fixed-length-tuples
	
	schema = "foo" | "bar" | 7 # schema must be one of these literals -- but don't these need to be 'fields' so we can do the error message properly?
	
	rule MinLength($length: number) {
		type: string
		message: "Must be at least ${length} characters"
		# We can't put the actual code this here... I guess this will act like graphql's "scalar" and you'll have to fill
		# in the logic on the backend...?
	}
	
	field FirstName = < # should the keyword be "field" or just "type"? The <> already denote this is a 'field' type -- I guess that depends on if schemas can be types or must be fields
		rule: MinLength(2)
	>

In Form Capacitor 2, everything is a "field". An entire form is just a complex field. A "DateTime" must consist of two sub-fields: "Date and Time". A "Scheduling Instruction" (see examles) is a complex field with several subfields. Therefore the schema root should also be a field, and we should not allow objects, or union types at the root (above examples should be invalid).

But if everything is a field, and each field has its own name and error message, are we not doubling-down on the errors?

	schema <
		name: "Scheduling Instructions",
		message: "The form is invalid",
		rule: <
			type: { # the type has to be a type. in this case it's an object, and we are defining it inline
				instructions: <
					# how *do* we define this as an array..!?!
					# it should be an array of Instructions, but Instruction is not a type, it's a field
					type: []
				>
			}
		>
	>

TypeScript and GraphQL differ in how they document arrays. In GraphQL `[Int]` is an arbitrary-length array.
In TypeScript `[number]` is a tuple with 1 element, which is a number, and `number[]` is an array of numbers. They
also allow `Array<number>` (see https://www.typescriptlang.org/docs/handbook/basic-types.html#array). I think we
should only allow one syntax. And `(number | string)[]`. I think we should go with the last one, since we want to
save angle brackets for "fields".

Operators:

	|    or
	&    and
	^    -xor-[oneOf] (one or the other but not both -- can *sort of* translate to JsonSchema via OneOf?? -- what is a^b^c? Is that "one of" a, b, or c but not two or more? Or... (a^b)^c?
							which would mean if a and b are the same truthiness then c must be true, but if they differ then a^b is true, so c must be false... so
							a^b^c^d^... is basically like checking if an odd number are truthy
							but maybe ^ *shouldn't* be a binary operator in our language and if you want it to be, you can add parens!!
							ergo, a^b^c means "one of" and (a^b)^c acts like traditional xor. So... ^ is just the "one of" operator then.
							
Our DSL should *require* parens when mixing operators so that order of operations is never a concern!!


https://spacetelescope.github.io/understanding-json-schema/reference/array.html

	schema <
		name: "Scheduling Instructions",
		message: "The form is invalid",
		rule: <
			type: "object",
			properties {
				instructions <
					name "Instructions"
					type "array"
					items <
						type "object"
						properties {
							typeId <
								type "number"
								minimum 1
								multipleOf 1
							>
						}
					>
				>
			}
		>
	>
	
	fragment Id <
		type "number"
		minimum 1
		maximum 4294967295
		multipleOf 1
	>

FEATURE: run-time values. allow supplying list of valid options for enums... either when .validate() is called, or when 'building' the schema.

Maybe we should do naming like how PegJS does it? Inline after the type...

	Integer "integer"
	  = _ [0-9]+ { return parseInt(text(), 10); }



	schema "Scheduling Instructions" {
		type object
		message "This form is invalid"
		properties {
			instructions "Instructions" {
				
			}
		}
		
	}

Should we use "!" to mean required like GraphQL? Should the default be required or optional? Or maybe "*" like is common with forms?

Every schema needs a type. It can have "multiple types" (really just a union type, aka anyOf)

	schema: object {
		name: "Scheduling Instructions"
		properties: {
			instructions: array {
				minLength: 1
				items: object {
					properties: {
						typeId: Id {
							name: "Appointment Type"
						}
						teamId: Id {
							name: "Team"
						}
						disciplineId: Id {
							name: "Discipline"
						}
						prefClinicianId: Id {
							name: "Pref Clinician"
						}
						childRequired: Boolean <
							name: "Child Req'd"
						>
					}
				}
			}
		}
	}
	
	Id: number {
		minimum: 1
		maximum: 4294967295
	}
	
Can't use {} for both "name" and "minimum"...

schema/field properties:
- name
- description
- default
- formatter

type properties:
- minimum
- maximum
- minLength
- properties
- ...

	schema SchedulingInstructions {
		name: "Scheduling Instructions"
		default: {
			instructions: []
			specialNote: ""
		}
		type: object<
			properties: {
				instructions: {
					type: array<
						minLength: 1
						items: object<
							properties: {
								typeId: {
									name: "Appointment Type"
									type: Id
								}
								teamId: Team
							}
						>
					>
				}
			}
		>
	}
	
	type Id = number<
		minimum: 1
		maximum: 4294967295
	>
	
	schema Team {
		name: "Team"
		type: Id
	}
	
	schema Instruction {
		type: object<
			properties: {
				typeId: {
					name: "Appointment Type"
					type: Id
				}
				teamId: Team
			}
		>
	}
	

Flow uses {| blah |} for [exact] type definitions...
	https://github.com/graphql/graphql-js/blob/bc33f2e5382f454f8576e23e9a604c929d21e013/src/utilities/extendSchema.js#L36
Exact object types: https://flow.org/en/docs/types/objects/#toc-exact-object-types

Alternatively... for objects, maybe we *do* just want to launch right into their "properties" and use some other syntax for defining meta-data..?

According to JSON schema (https://spacetelescope.github.io/understanding-json-schema/reference/object.html), the valid 'options' for an object are:
- properties
- required
- minProperties
- maxProperties
- dependencies
- patternProperties
- additionalProperties <-- similar to TypeScript's "index signature"
	*BUT* we're only supporting JSON types, which means the keys can only be strings (not Symbols), however, we may want to document the type (like JsonSchema)... so maybe we should do `*: string`

We could use {} as a shorthand for "object with properties"
But if {} exclusively means "object" then we need a different token for schemas... so here we go again..

Actually, the "name" can kinda be like a Python doc-string (GraphQL also switched to using strings!): http://www.pythonforbeginners.com/basics/python-docstrings Although they use that for the description, ours is more of a title/name that'll be used in the error messages.. Hmmm...

But we were using <> to be an inline extension...

	schema SchedulingInstructions (
		name "Scheduling Instructions"
		default {
			instructions: []
			specialNote: ""
		}
		type { # type is an object with the following properties. this is shorthand syntax for `type object<properties{`
			instructions (
				name "Instructions"
				type {
					typeId {
						name "Appointment Type"
						type Id
					}
				}<minLength 1>[]
			)
		}
	)
	
Braces: ({[<

{ object
[ array
( schema
< extends

TODO: syntax for optional.... https://stackoverflow.com/a/37166319/65387
	https://www.typescriptlang.org/docs/handbook/interfaces.html#optional-properties
	
i.e. we'll put a ? after the property name

and ? before the type makes it a nullable type (maybe.... | null works just as easily)

==============================================================================

schema SchedulingInstructions (
	name "Scheduling Instructions"
	default {
        instructions: []
        specialNote: ""
    }
    type {
        instructions (
            name "Instructions"
            type array<
                minLength 1
                items {
                    typeId (
                        name "Appointment Type"
                        type Id<
                            message "Invalid Appointment Type" # Syntax for {..name} and {minimum} and {maximum}?
                        >
                    )
                    teamId (
                        name "Team"
                        type Id
                    )
                    disciplineId (
                        name "Discipline"
                        type Id
                    )
                    prefClinicianId? PrefClinician
                    prefTime? (
                        name "Pref. Time"
                        type (null | 30 | 60 | 90 | 120 | 150 | 180)<
                            message "Invalid time"
                        >
                    )
                }
            >
        )
    }
)

type Id = number<
	minimum: 1
	maximum: 4294967295
	message "Invalid option"
>

type OptId = Id | null

schema PrefClinician (
    name "Pref. Clinician"
    type Id | null
)

type CreditCard = string<
	pattern /\d+/
	minLength 13
	maxLength 16
>

type ValidTimes = null | 30 | 60 | 90 | 120 | 150 | 180
type ValidTimesError = ValidTimes<
	message "Please select a valid time"
>

==============================================================================

TODO: real-time/online validations vs onBlur validations?
^- maybe an extra property called `runType`?
^-- but how would we bake "runType" into the CC type above..?

Union type with all constants as options should have a nice default error message.

TODO: run-time $variables